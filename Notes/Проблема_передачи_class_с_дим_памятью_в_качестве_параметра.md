# Проблема
Если в классе используется какой-то выделяемый ресурс (пр: динамическая память ) то при передаче таких объектов в качестве параметров могут возникнуть проблемы с выделяемым ресурсом.
Рассмотрим ситуацию 
```

class my{
	int *p;
	public:
	my(int i){
		std::cout<<"new memory"<<'\n';
		p = new int;
		*p=i;
	}
	~my(){
		std::cout<<"free memory"<<'\n';
		delete p;
	}
	int get_val() {return *p;}
};

void display(my ob){
	std::cout<<ob.get_val()<<'\n';
}
int main(){
    my a(10);
	display(a); // 

}
```
этот код выведет
```
new memory
10        
free memory
free memory
```
Как мы видим у нас память освобождается дважды, возникает вопрос почему ?
А проблема в том что здесь ф-я создает побитовую копию объекта `ob`(точную копию), а потом по окончанию блока кода вызывается деструктор для этой копии, а так как указатель и у копии и оригинала одинаковый, то страдает и оригинал объекта. он становится невалидным.

Но ситуация на самом деле ещё хуже, ведь по завершению `main()` созданный в ней объект `a` тоже разрушается отсюда и второе освобождение памяти. Это очень серьезнапя ошибка ведь она ведет к неисправимой ошибке.

Так как же этого избежать ?

## 1 способ(простой)

Достаточно передавать не копию объекта, а указатель на него или ссылку.
ПР
```
class my{
	int *p;
	public:
	my(int i){
		std::cout<<"new memory"<<'\n';
		p = new int;
		*p=i;
	}
	~my(){
		std::cout<<"free memory"<<'\n';
		delete p;
	}
	int get_val() {return *p;}
};

void display(my &ob){
	std::cout<<ob.get_val()<<'\n';
}
int main(){
    my a(10);
	display(a); // 

}
```
В таком случае, не создается копия и следовательно деструктор не вызывается второй раз.
Этот код выдаст
```
new memory
10
free memory
```
## 2 способ(создание конструктора копии, его перегрузка)

!!!!!сылка на конструктор копии!!!
Конструктор копии позволяет нам задать каким образом мы хотим чтоб объект копировался.
Он помогает решить проблему передачи объекта или возвращения его из ф-и(об этом дальше)
Для начала ещё раз сформулируем проблему. При передачи объекта в ф-ю создается его побитовая копия, которая передается в параметру этой ф-и. Однако возмодны ситуации когда эта копия нежелательна. Например если в оригинальном объекте есть указатель, в таком случае копия будет указывать на ту же ячейку в памяти что и оригинал, следовательно, если копия внесет изменения в объект, то они отразятся и на оригинале! 

Аналогичная ситуация может возникать и при возврате объекта из ф-и, потому что компилятор генерирует временный объект, возвращаемого ф-ей.(он делается автоматически, без нашего на то согласия).Этот временный объект выходит за пределы видимости сразу же, как только инициатору вызова этой ф-и будет возвращено <обещанное> значение, после чего незамедлительно вызовется деструктор временного объекта. Но такой деструктор всё так же может быть опасен для оригинала.

Эти проблемы возникают из-за побитовой копии объекта, и чтоб определить как иначе мы хотим копировать объект нам и нужен конструктор копии.

Важно заметить, что в с++ значение одного объекта присваивается ток в 2 ситуациях:
1) Присваивание (такая же проблема и при перегрузка оператора `==` , но об этом потом)
2) Инициализация ( тут три варианта)
		1)Один об явно инициализирует другой (объявление)ж
		2)Копия об передается параметру ф-ию
		3)Генерация временного объекта(чаще всего в качестве значения передаваемого ф-ей)

вот инициализация на примерах 
```
my x = y;     // Об y явно инициализирует об x
func1(y);     // Об y передается в качестве аргумента
y = funcl2(); // Об y принимает об, возвращаемый ф-ей такой случай может 
// оптимизировать современным компилятором, поэтому возможно и не будет           //использоваться
```
**!!!!Конструктор копии вызывается ток при ИНИЦИАЛИЗАЦИИ!!!!**	


общая форма конструктора копии
```
 имя_класса(const имя_класса &твое_название){
	 // тело конструктора
 }
```

Вернемся к нашему примеру

Вот так он будет выглядеть для нашего класса my
```
// в книге не было, мои дописки, по идее верно 
my(const my &ob){
		p=new int; // выделяем новую память для временного об, чтоб именно она     //отчистилась деструктором
		*p=*ob.p; переносим значение
	}
```

А теперь весь код 2 варианта исправления 
```

class my{
	int *p;
	public:
	my(const my &ob){ // тут ob это копируемый класс
		std::cout<<"new memory (copy construct)"<<'\n';
		p=new int;
		*p=*ob.p;
	}
	my(int i){
		std::cout<<"new memory"<<'\n';
		p = new int;
		*p=i;
	}
	~my(){
		std::cout<<"free memory"<<'\n';
		delete p;
	}
	int get_val() {return *p;}
};

void display(my ob){
	std::cout<<ob.get_val()<<'\n';
}
int main(){
    my a(10);
	display(a); // 
}
```
Этот код выводит 
```
new memory                  // создали a
new memory (copy construct) // копировали а в a-ю при помощи оп копирования
10 
free memory  // уничтожение копии объекта
free memory  // уничтожение a
```

Вот два метода исправления этой проблемы

## Ещё один пример с конструктором копии

Тут как раз копия об возвращаемого ф-ей
```
class my{
	
public:
	my(const my &ob){
		std::cout<<"copy construct"<<'\n';
		
	}
	my(){
		std::cout<<"defolt construct"<<'\n';
	}
};
my f(){
	my ob; // defolt construct
	return ob; // copy construct
}

int main(){
    my a; // defolt construct
	a = f(); // copy construct
	return 0;
}
```
Он уже оптимизируется компилятором, так что вывод такой
```
defolt construct
defolt construct
```
Собственно про оптимизацию
![[Pasted image 20250127183617.png]]
![[Pasted image 20250127183629.png]]