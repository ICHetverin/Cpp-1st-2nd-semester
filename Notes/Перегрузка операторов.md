Операторы можно перегружать
ОБЩАЙ ПРИМЕР:
```
тип имя_класса::operator#(список аргуметов){ //# это любой знак
	оклд
}
```
**Перегружать нельзя "." "::" "?" ".*"**

# Перегрузка операторов с использованием ф-й членов
## Общий случай

[[оператор_код_1(члены_класса)]]

ПР:
```
//gcc 7.4.0
#include <iostream>
#include  <stdio.h>

class th{
    int x,y,z;
    public:
    th():x(0),y(0),z(0){}
    th(int _x, int _y, int _z):x(_x),y(_y),z(_z){}
    th operator+(th ob){
        th temp;
        temp.x=x+ob.x;
        temp.y=y+ob.y;
        temp.z=z+ob.z;
        return temp;
    }
    th operator=(th ob){
        x=ob.x;
        y=ob.y;
        z=ob.z;
        return *this;
    }
    void show(){
        std::cout<<x<<'\n';
        std::cout<<y<<'\n';
        std::cout<<z<<'\n';
        std::cout<<'\n';
    }
};
int main()
{
    th a(1,2,3),b(10,10,10),c;
    a.show();
    b.show();
    c = a + b; // сложение объектов 
    c.show();
    
    c = a + b + c; // множественное сложение объектов
    c.show();
    c=a=b; // множественное присваивание
    c.show();
    return 0;
}
```

Можно задаться вопросом почему бинарному оператору передается ток 1 аргумент, но это объясняется достаточно просто.
```
temp.x=x + ob.x;
```
cдесь x млжно расписать как 
```
this->x
```
т е x связывается с объектом который его вызывает и он передается неявно.

**Так мы видим что для унарного оператора вообще нет аргументов(operator++()), а для бинарного он ток 1(operator=(...).**


```
a + b + c
```
такая операция возможна ток благодаря тому что оп+ возвращает объект tr. 

**Важно:**
**оп= модифицирует себя поэтому он возвращает *this**
## Использование ф-й членов для перегрузки унарных операторов


Возможна и перегрузка оп ++, --
Как упоминалось выше в таких случаях аргумент передается неявно  (через this)

ПР Префиксная форма ++:
```
th operator++(){
	x++;
	y++;
	z++;
	return *this;
}
```
Теперь рассмотрим постфиксную форму оператора ++
```
th operator++(int i){ // i не используется
        th temp = *this; // сохранения текущего значения
        x++;
        y++,
        z++;
        return temp;
    }
```
i не используется и показывает компилятору что мы перегружаем постфиксную форму ++
(является индикатором для компилятора)

# Перегрузка операторов с использованием ф-й не членов

**Бинарные операции не являющиеся членом класса имеют 2 аргумента, а** 
**унарные 1**

## Бинарные операторы
Это происходит из-за того что вне класса не существует this следовательно нам нужно я вно передавать оба аргумента.

**нельзя перегружать =, (), [], ->**

Такие ф-и часто являются ф-ми друзьями (friend).

[[оператор_код_2(friend)]]
```
class th{
	friend th operator+(th ob1, th ob2);
};
th operator+(th ob1, th ob2){
    th temp;
    temp.x=ob1.x+ob2.x;
    temp.y=ob1.y+ob2.y;
    temp.z=ob1.z+ob2.z;
    return temp;
};
int main()
	th a(1,2,3),b(10,10,10),c;
	c = a + b;
	c.show();
```
Здесь  ob1 это левый параметр, а ob2 это правый параметр.

Такие ф-и друзья используются достаточно редко, но в некоторых случаях они сильно выручают. Один из них возникает, когда нужно сложить какой-то объект с встроенным типом данных
```
int a=10;
th s(1,2,3),d;
d=s + a; 
```
При таком варианте мы ещё можем обойтись без использования ф-и друга, так как оператор вызывается объектом находящемся слева от него(в данном случае это s для которого мы перегрузили оператор+), но если мы поменяем местами слагаемые, то тут вылетит ошибка.
```
d=a + s; // ошибка
```
Так как мы не можем определить оператор сложения для стандартного типа int.
 в таких случаях нам и нужны ф-и друзья.
 ```
 th operator+(int a, th s){
	 th temp;
	 temp.x=s.x+a;
	 temp.y=s.y+a;
	 temp.z=s.z+a;
	 
 }
```

## Унарные операторы

С помощью ф-й друзей можно перегружать и унарные операторы, но для этого нужно приложить больше усилий так-как this всё так же нет вне класса.
Поэтому такой вариант работать не будет
```
th operator++(th ob1){ //не работает !!!
	ob1.x++;
	...
	return op1;
}
```
Не работает из-за того что при вызове ф-и создается копия объекта и все изменения вносятся в нее а не в оригинальный объект.
Чтоб избежать такой проблемы стоит передавать объект по ссылке, поскольку ссылочный параметр является неявным указателем на объект, тем самым его меняя.
```
th operator++(th &ob1){ // &ob1!!!!
	ob1.x++;
	...
	return op1;
}
```
Это префиксная реализация, для постфиксной нужно( как и в ф-и члене класс) дописать int значение в параметр (оно никак не использует и является ток индикатором для компилятора)
```
th operator++(th &ob1, int i){ // &ob1!!!!
	th temp = ob1;
	ob1.x++;
	...
	ob.z++;
	return temp;
}
```

# Логические операторы 
Они реализовываются точно так же, ток возвращают логическое значение(true/false)
ПР:
```
bool operator==(th ob){
	if(x==ob.x) && (y==ob.y) && (z==ob.z) return true;
	else return false;
}
int main(){
	th a(1,2,3), s(1,2,3);
	if(a==s)std::cout<<1;
	else std::cout<<0;
	return 0;
}
```

Подробнее про оператор присваивания
Описывается оператор копирования 
[[Подробнее об операторе присваивания]]
