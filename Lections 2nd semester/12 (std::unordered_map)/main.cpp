#include <iostream>

/*
* std::unordered_map internals
    (since c++ 11)
-------------------------------------------
* Methods: expected O(1)
    *- insert()
    *- erase()
    *- find()
    *- reserve()

    *- double load_factor()
    *- get_max_load_factor()
    *- set_max_load_factor()

    для закрытой адресации используется vector<forward_list<Node>> arr
    это работает только если без итераторов

    * Forward iterator
    мапа должна обходиться за O(n)
    n - кол-во элементов, лежащих в мапе
-----------------
* Делаем один большой forward_list
    теперь в ячейках хранятся итераторы на forward_list (buckets)

* find
    идем в вектор смотрим ячейка пуста или нет
    будем хранить хэш на каждйо ноде и сравнивать, чтобы определить бакет

* insert
    проходимся по бакету, если что вставляем в конец в бакете
    если пустота - делаем новый бакет в начале списка

* erase
    вопрос с тем как поменять указатели предыдущего на удаляемый
    1) сделать двусвязный список (Microsoft)
    2) хранить указатель на конец предыдущего бакета
        (insert если пустота (новый бакет))
        при insert будем хранить значение первого хэша
        и будем добавлять новую ноду в наш лист в начало
        так чтобы новая наша указывала туда, куда указывала фейковая

    теперь erase (удаление последнего элемента бакета)
    на него указывает ячейка из массива (нужно чтобы указывала на пред)
    смотрим, куда указывает наша ячейка
    ну и смотрим хэш от след после нас
    в ячейке от этого хэша присваиваем наш пойнтер (на пред бакет)

* rehash
    много раз erase последовательно и insert в новый

* при insert и при erase указатели и ссылки НЕ инвалидируются
*/

template <typename Key, typename Value>
struct Node {
        std::pair<const Key, Value> kv;
        uint64_t hash;
};
