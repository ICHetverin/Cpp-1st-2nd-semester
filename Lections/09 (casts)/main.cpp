#include <iostream>

/*
    * 5 Types of casts

    * Static cast
        Если нужно сделать, то не знаем какой из всех 5 выбрать,
        то это он
        * Пример: (это все явные приведения)
        int -> double
        double -> int
        Числа туда - сюда, булы
        * Создается новый объект, просто численно равный (с округлением) данному
        * Любой указатель в указатель на void*
        * Массив к указателю

    * Reinterpret cast
    ! Заклинания черной магии - которые как бы ну а что зачем
        Способ взять биты одной переменной и положить трактовать их как биты другой
        Ну то есть типа long -> double (там 64 бита лонга пойдут в биты дабла) и это UB
        * Можем брать и больше битов одной переменной (long -> int)
        * Нельзя делать к новому объекту, только к указателю или к ссылке, но не к копии
        * Может любой к любому -> но нельзя читать одни и те же биты по разному
        * Полезно, когда порядо битов одинаков в двух структурах
        * Ну вот единственное, нельзя конст к не конст конвертировать

        * Два фактических способа
        1) & - приведение одного типа к ссылке на другой
        2) * - приведение типа к пойнтеру или пойнтера к пойнтеру

    * Const cast
    ! Заклинания самой черной магии - которые как бы зачем ты тогда консты делаешь
        Вот он как раз и нужен для каста конста к не конст и вот это все
        Такое бывает нужно, чтобы что?
        Трудно - непонятно пока зачем
        * Тоже два способа
        1) & - приведение одного типа к ссылке на другой
        2) * - приведение типа к пойнтеру или пойнтера к пойнтеру

    * C-style cast
    ! Ну епт твою мать - ты зачем вообще это делаешь, дурачок?
        Каст пытается быть конст кастом
        Потом он пытается статиком
        Потом он пытается статиком, на котором навешен конст
        Потом он пытается реинтепретом
        Потом он пытается реинтепретом, на котором навешен конст
        ! Что - вообще почему ты это делаешь и зачем
        И вот только если все предыдующие не сработали - то это CE
        А еще!!
        ты можешь закастить конст к чему через с-style
        он вдруг выберет себе конст каст
        ты будешь уверен, что все окэ
        изменишь этот конст и все пздц...
        UB короче

    * Dynamic cast
        ну это потом

    ! Сам Страуструп говорит, что касты это плохо и говнокод короче
    Он говорит что все называетя так сложно и непонятно, чтобы вы не юзали это почти никогда, а боялись
*/

void f(const int& c) {} // вот тип здесь можно внутри юзать
// const cast, ЕСЛИ ВЫ УВЕРЕНЫ что по конст ссылке приходить обычная ссылка
// просто тогда вопрос - а зачем ты так делаешь в своем коде??

int main() {
    {   //* Reinterpret cast
        long long y = 1729;
        double& d = reinterpret_cast<double&>(y); // UB
        d = 3.14;
        std::cout << y << std::endl; // все поломалось
        // ну потому что нельзя брать биты одного вида и класть их в новый тип
        // также такой каст - это скорее
        // посмотреть на старый объект, как будто он другого типа, в отличии от static
    }
    {   // Полное UB
        int x = 5;
        int* p = &x;
        std::string* str = reinterpret_cast<std::string*>(p);
        std::cout << str << std::endl;
    }
    {   //* Const cast
        const int c = 5;
        int& cc = const_cast<int&>(c) = 10;
        cc = 7;
        std::cout << c << " " << cc << std::endl; // Вот это уже UB
        // передавать вещь которая константа и изменять ее - это UB
    }
    {
        //* C-style cast
        const int a = 5;
        int b = (int)a;
        b = 100;
        std::cout << a << std::endl;
        // ну вот все - зачем
    }
}