#include <iostream>

/*
    * 4 steps of building program
        * 1) Preproccessing
        * 2) Compiling
        * 3) Assembling
        * 4) Linking

    * 1) Препроцессинг
        ну всякие директивы для прцессора
        #include (тупо копипаста из файла)
        если это <>, то ищем в стандартных папках
        #if
        #pragma
        Файл все еще в формате cpp, просто все директивы выполнены
        все подставлено
    * 2) Компиляция
        Код с++ -> код на ассемблере
        из файла .cpp -> файл .s
    * 3) Ассемблирование
        Сборщик
        Код на ассемблере -> код на машинном коде
        .s -> .o
        прям с инструкциями для процессора
    * 4) Линковка
        Что произошло - есть машинный код, есть какие файлы, которые мы заинклудили
        Но если посмотреть, то это ведь почти всегда объявление, а не определение функции
        (ну хэдер)
        так вот, чтобы все функции были правильно вызваны и нужен линковщик
        он подставляет на место вызова функции определение этой функции
        .o -> .out

    * Чтобы попробовать можно запустить сборку с флагом -v

    * Так пробуем смотреть как это все выглядит
        вместо [] вставляем свои названия

        Препроцессинг
        1) [clang++] -E [main.cpp] > [output.cpp]

        Компиляция
        2) [clang++] -S [main.cpp]
        Ассемблерный код

        Объектный файл
        3) [clang++] -c [main.cpp]
        cat [main.o]
        hd [main.o]

        Сборка в исполняемый файл
        4) [clang++] [main.o] -o [main.out]

        Выполнение
        5) [./main.out]

    * Санитайзеры
        Помогают ловить UB
        Компиляторные флаги, которые включают санитайзеры
        -fsanitize=address
        -g - строчки из файла
        -fsanitize=undefined (поведение)
        -fsanitize=leak (утечки памяти)
        Но санитайзеры оч тяжелые штуки - раз в 5 увеличивают время выполнения
*/

int main() {
    std::cout << "Hello World!" << std::endl;
}