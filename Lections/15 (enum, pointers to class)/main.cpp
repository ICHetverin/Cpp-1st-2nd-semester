#include <iostream>

/*
    * Enum
    * Pointers to methods and members
*/

struct S {
    int x;
    double y;

    void f(int z) {
        std::cout << (x + z) << std::endl;
    }
};

// version v1.0
enum E0 {
    White,
    Gray,
    Black
};

// version v1.1
// запрещает конверсию + нет глобальности для констант
enum class E1 {
    White,
    Gray,
    Black
};

// version v1.2
enum class E2 : uint8_t {
    White,
    Gray,
    Black
};

int main() {
    {   //* pointer to member
        int S::*p = &S::x;
        S s{1, 3.14};
        std::cout << s.*p << std::endl;
        // P по сути число, хранящее сдвиг относительно структуры
        // Насколько можно сдвинуться
        // .* - отдельный оператор
        S* ps = &s;
        std::cout << ps->*p << std::endl;
        s.*p = 15; // x = 15
        /*
            Зачем такое может быть нужно
            Есть структура ребра
            И нужно реализовать обход, в том числе и ребра
            У ребра есть начало и конец, но не хочется писать копипасту на два случая
            Берем вместо ссылки на объект поля класса ссылку на поле класса
            И тогда в зависимости от начало/конец можем закинуть в функцию обхода
            концы в противоположном направлении
        */
    }
    {
        void (S::*pf)(int) = &S::f;
        // Кстати pf здесь будет именем
        S s{1, 3.1};
        (s.*pf)(3);
        // Это уж совсем какая-то черная магия
        /*
            Зачем такое надо
            В QT активно используется указатели на методы
            Там в функцию передается указатель на класс, на метод этого класса
            на 2 класс, на метод 2 класса
            и при исполнении 1-го метода вызывается 2-ой
        */
    }
    {
        // E e = White; // for version v1.0
        E2 e = E2::White; // for version v1.1
        int a = E2::White; // запрещены неявные касты enum к кому-либо и обратно в enum
        std::cout << a << std::endl;
    }
}