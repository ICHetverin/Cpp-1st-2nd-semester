#include <iostream>

/*
    *Операторы присваивания
    =, +=, *=, %=, /= и т.д.
    (lvalue, все остальные операторы rvalue)
    лефту можно еще что-то присвоить, а райту уже нет
    lvalue занимает четкое место в памаяти, а rvalue - нет
    rvalue может быть результатом каких-то операций
    (которые хранятся во временнем регистре во время вычислений например)
    (a + 1) - rvalue

    В С++ 17
    остается, что && или || при переопределении для ваших типов,
    он будет вычисляться лениво (допустим, только одну лево (0, 1))

    Тернарный тоже вычисляется лениво
    Если нельзя найти один тип, для двух на 0 и 1 - то будет ошибка при компиляции

    *Оператор , НО НЕ ВСЕГДА ОПЕРАТОР
    (a, b) - возвращает b, НО вычисляет обязательно a

    *sizof
    Важно запомнить, что sizeof и size, допустим в векторе выдают самые разные значения
    sizeof - суммарный размер полей в байтах (const на размер компиляции)
    size - колво элементов в векторе (меняется в рантайме)

    *side effects
    Допустим += - два действия (подстановка переменной и увеличение)
    side effect - увелечение переменной, как действие

    *switch
    лучше оптимизируется чем ифы
    switch (x) {
    case 1:
    case 2:
    default:
    }

    *бывают еще label
    label:
        ...
    goto label
    !goto в другой scope нельзя, но наружу можно
*/

int f() {
    std::cout << 1;
    return 1;
}

int g() {
    std::cout << 2;
    return 2;
}

int h() {
    std::cout << 3;
    return 3;
}

int main() {
    // Операторы присваивания
    {   // lvalue
        int x, y = 5;
        std::cout << (x = y); // 5
        int z = 15;
        std::cout << ((x = y) = z); // 15
    }
    {
        // Например
        // a * a * a * a * a ... (a - float)
        // компилятор не умеет (a * a) * (a * a) * ..
    }
    {
        int a = 0;
        // rvalue a++;
        // lvalue ++a;
        std::cout << ++(a = 5) << std::endl; // тк lvalue = 6
        std::cout << (++a = 5);
        // ++a++ - зависит от парсинга комплиятора
        // постфикс - приоритетнее, поэтому нельзя выполнить - будет rvalue
        int b = 3;
        std::cout << '\n' << ++++a; // тк lvalue, делится по лексемам
        // std::cout << a+++++b - нельзя, тк rvalue (нельзя с ним дальше работать)
        std::cout << '\n' << a+++b; // 11 - так можно
    }
    {
        int a = 6;
        std::cout << '\n' << (a++, a++, ++a); // 9
    }
    {
        std::cout << '\n' << f() * g() + h(); // выражение точно определено, но внури может по-другому
        // в плане что могло выйти не 123, а 312 допустим, НО ответ был бы однозначен
        // order of evaluation
        int x = 0;
        x = ++x + x++; // UB
        std::cout << '\n' << x;
    }
    {
        int x = 2; // не оператор присваивания!!!! а просто инициализатор
        switch(x) {
        case 1:
            std::cout << "\nA";
            break;
        case 2:
            std::cout << "\nB";
        default:
            std::cout << "\nC";
        }
        // 2 - B C
    }
    {
        // так можно инициализировать с 17
        if (int x = 10; x <= 10) {
            std::cout << "\nYES";
        } else {
            std::cout << "\nNO";
        }
    }
}