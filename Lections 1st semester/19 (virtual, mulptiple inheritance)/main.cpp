#include <iostream>

/*
    * Casts

    * Public inheritance
        * Derived -> Base

        type of cast     |   copy    |   ptr    |   ref   |
        _________________|___________|__________|_________|
        implicit         |    OK     |    OK    |   OK    |
        --------------------------------------------------|
        static_cast      |    OK     |    OK    |   OK    |
        --------------------------------------------------|
        reinterpret_cast |    CE     |    OK    |   OK    |
        --------------------------------------------------|

        * Base -> Derived (Base умеет меньше операций чем Derived)
        ну как с const - так же также
        const умеет просто меньше операций чем обычный тип

        type of cast     |   copy    |   ptr    |   ref   |
        _________________|___________|__________|_________|
        implicit         |    СЕ     |    СЕ    |   СЕ    |
        --------------------------------------------------|
        static_cast      |    СЕ     |    ОК    |   ОК    |
        --------------------------------------------------|
        reinterpret_cast |    СЕ     |    ОК    |   ОК    |
        --------------------------------------------------|
        * Но по всем где ОК (будет UB), если только уверены что там Derived
        реально лежит, а не Base

     * Private inheritance
        * Derived -> Base

        type of cast     |   copy    |   ptr    |   ref   |
        _________________|___________|__________|_________|
        implicit         |    CE     |    CE    |   CE    |
        --------------------------------------------------|
        static_cast      |    CE     |    CE    |   CE    |
        --------------------------------------------------|
        reinterpret_cast |    CE     |    OK    |   OK    |
        --------------------------------------------------|
        CЕ много где, потому что private поля - нет доступа

        * Base -> Derived (Base умеет меньше операций чем Derived)
        ну как с const - так же также
        const умеет просто меньше операций чем обычный тип

        type of cast     |   copy    |   ptr    |   ref   |
        _________________|___________|__________|_________|
        implicit         |    СЕ     |    СЕ    |   СЕ    |
        --------------------------------------------------|
        static_cast      |    СЕ     |    CE    |   CE    |
        --------------------------------------------------|
        reinterpret_cast |    СЕ     |    ОК    |   ОК    |
        --------------------------------------------------|
        * Но по всем где ОК (будет UB), если только уверены что там Derived
        реально лежит, а не Base
*/
/*
    * Multiple inheritance

    По сути, если есть два касса, от обоих наследуется наш
    То он естесвтенно хранит все поля, но что происходит с указателями
    class Son : public Mom, public Dad {}
    пусть так, и у всех трех классов есть по инту внтури
    В памяти - это так:
        |  Mom(int)  ||  Dad(int)  ||  Son(int) | 12байт
    Но при касте что происходит?
        void f(Dad*) {};
        f(&Son);
    Тут естественно скастится указатель Сына на указатель Отца (он просто подвинется на 4 вправо в памяти)

    Если и в Папе и в Маме поля (функции) с одинаковыми именами, то будет перегрузка между ними
    Естественно, если у сына нет фции с тааким именем (иначе она затмит эти две функции до этого)


    * Существует такая проблем (Diamond problem) ромбовидное наследование
    Потому что два родителя унаследованы от одной бабушки, и от этих двух родителей создается объект сына
    Все поля останутся (поля Гpэнни будут два раза)
        | g | m | g | d | s |
    При обращении к Грэнни будет ошибка вызова (непонятно к какой обращение)
    Если делать каст к Грэнни (неоднозначный каст)
    Есть ведь две разных бабушки - непонятно к какой
    Чтобы к кому скаститься - нужно сначала каст к этому родителю и только потом каст к прородителю этого родителя
    Каст от одного родителя к другому в таком случае нельзя сделать

    * Можно еще так Granny -> Dad -> (Son) <- Granny
    В таком случае поля бабушки, от которой напрямую наследуется сын будут inaccessible Base class
    Будет неоднозначность для этой бабушке
*/
/*
    * А вот щас круто
    Пусть у нас есть классы Mom and Dad (у каждого есть функция f())
    Если мы хотим взять указатель на метод класс Son от этой функции, то это же разные
*/
/*
    * Virtual inheritance

    Пусть снова буду Мама и Папа
    Теперь хотим наследоваться так, чтобы две части одинаковых полей не оставались, а было только одно
        struct Mom : public virtual Granny {};
    Вот оно виртуальное наследование
    И теперь при кастах все будет нормально - не будет неоднозначности
    Теперь значи как устроено будет то же самое
            Granny --> Mom -\
                  `--> Dad --> Son
    Но при этом Mom и Dad виртуально наследованы
    Тогда в паямти будет храниться Mom, Dad + (в каждом указатели на Granny) Granny и собственно Son
    | ptr to Granny (from Mom) | Mom | ... padding ... | ptr to Granny (from Dad) | Dad | Son | Granny | ...padding... |
                 8                                                   8
    Будет создана особая структура для каждого из предков и сына
    "Таблица", в которой будет определен сдвиг до Грэнни
    * VTable - хранится в статической памяти
    * Topoffset - такая еще штука есть в этой же таблице (это от самого начала объекта)
    static_cast при касту вниз (от бабушке к внуку) не работает, поскольку куда переходить непонятно
*/

struct Mom {
    void f() {
        std::cout << 1 << std::endl;
    };
};

struct Dad {
    void f() {
        std::cout << 2 << std::endl;
    };
};

struct Son : Mom, Dad {
};

int main() {
    {
        // Вот такая шляпа
        // Надо суметь смочь так сказать сделать
        // Указатель на метод класса Mom
        Son s;
        void (Mom::*f)() = &Mom::f;
        (s.*f)();
        std::cout << sizeof(f) << std::endl;
        // 16 Потому что указатель на метод класса
        // состоит из двух частей
        // pointer to function | shift in memory from class address
        // И такое нужно, потому что мы можем же брать разные f от разных родителей
    }
    {
        Son s;
        void (Mom::*f1)() = &Mom::f;
        void (Dad::*f2)() = &Dad::f;
        void (Son::*f3)() = f2; // implicit cast
        // shift поменяется на 4
        (s.*f1)();
        (s.*f2)();
        (s.*f3)();
    }
}
